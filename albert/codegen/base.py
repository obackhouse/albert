"""Base class for code generation.
"""

import sys
import platform
import inspect
import datetime
from numbers import Number
from collections import defaultdict

from albert import __version__
from albert.tensor import Tensor


def kernel(
    codegen,
    function_name,
    returns,
    outputs,
    exprs,
    as_dict=False,
):
    """
    Generate the code for a function using a list of expressions.

    Parameters
    ----------
    codegen : CodeGen
        The code generation object.
    function_name : str
        The name of the function.
    returns : list of Tensor
        The return tensors.
    outputs : list of Tensor
        The output tensors.
    exprs : list of Algebraic
        The algebraic expressions.
    as_dict : bool, optional
        Whether to return the outputs as a dictionary. Default value is
        `False`.
    """

    # Get the arguments
    args = sorted(
        set(
            arg.name for expr in exprs for mul_args in expr.nested_view() for arg in mul_args
            if isinstance(arg, Tensor) and not arg.name.startswith("tmp")
        ),
    )
    rets = [ret.name for ret in returns]

    # Write the function declaration
    codegen.function_declaration(function_name, args)
    codegen.indent()

    # Write the function docstring
    metadata = codegen.get_metadata()
    parameters_str = "\n".join([f"{arg} : array" for arg in args])
    returns_str = "\n".join([f"{ret} : array" for ret in rets])
    docstring = f"Code generated by albert {metadata['albert_version']} on {metadata['date']}.\n"
    docstring += "\n"
    docstring += "Parameters\n----------\n"
    docstring += parameters_str
    docstring += "\n\n"
    docstring += "Returns\n-------\n"
    docstring += returns_str
    codegen.function_docstring(docstring)
    codegen.blank()

    # Find the last appearance of each tensor
    last_appearance = {}
    for i, (output, expr) in enumerate(zip(outputs, exprs)):
        for mul_args in expr.nested_view():
            for arg in mul_args:
                if isinstance(arg, Tensor) and arg.rank > 0:
                    last_appearance[arg] = i

    # Get the tensors to cleanup at each step
    to_cleanup = defaultdict(list)
    for arg, i in last_appearance.items():
        if not any(arg.name == r for r in rets) and not any(arg.name == a for a in args):
            to_cleanup[i].append(arg)

    # Write the function declarations
    for i, (output, expr) in enumerate(zip(outputs, exprs)):
        # Get the arguments and factors
        fargs = [arg for arg in expr.args if isinstance(arg, Tensor)]
        factors = [arg for arg in expr.args if isinstance(arg, Number)]

        # Write the declarations
        if output.rank == 0:
            codegen.scalar_declaration(output)
        else:
            codegen.tensor_declaration(output)

        # Write the expression
        codegen.algebraic_expression(output, expr)

        # Write the cleanup
        codegen.tensor_cleanup(*to_cleanup.get(i, []))

    # Write the function return
    codegen.blank()
    codegen.function_return(rets, as_dict=as_dict)
    codegen.dedent()
    codegen.blank()


class CodeGen:
    """Base class for code generation."""

    def __init__(self, name_generator=None, **kwargs):
        self.__dict__.update(kwargs)
        self._indent = 0
        self.stdout = sys.stdout
        self._name_generator = name_generator

    def indent(self):
        """Indent the code."""
        self._indent += 1

    def dedent(self):
        """Dedent the code."""
        self._indent -= 1

    def get_name(self, tensor):
        """Get a name."""
        if self._name_generator is not None:
            return self._name_generator(tensor)
        return tensor.name

    def write(self, string, end="\n"):
        """Write a string."""
        for line in string.split("\n"):
            if all(x == " " for x in line):
                self.blank()
            else:
                self.stdout.write("    " * self._indent + line + end)

    def blank(self):
        """Write a blank line."""
        self.stdout.write("\n")

    def get_metadata(self):
        """Get the metadata."""
        return {
            "node": platform.node(),
            "system": platform.system(),
            "processor": platform.processor(),
            "release": platform.release(),
            "user": platform.uname(),
            "caller": inspect.getframeinfo(sys._getframe(1)).filename,
            "date": datetime.datetime.now().isoformat(),
            "python_version": sys.version,
            "albert_version": __version__,
        }

    def module_imports(self):
        """Write the module imports."""
        raise NotImplementedError

    def module_preamble(self, preamble):
        """Write the module preamble."""
        raise NotImplementedError

    def module_docstring(self):
        """Write the module docstring."""
        raise NotImplementedError

    def module_postamble(self, postamble):
        """Write the module postamble."""
        raise NotImplementedError

    def function_declaration(self, name, args):
        """Write a function declaration."""
        raise NotImplementedError

    def function_preamble(self, preamble):
        """Write the function preamble."""
        raise NotImplementedError

    def function_docstring(self, docstring):
        """Write the function docstring."""
        raise NotImplementedError

    def function_postamble(self, postamble):
        """Write the function postamble."""
        raise NotImplementedError

    def function_return(self, args, as_dict=False):
        """Write the function return."""
        raise NotImplementedError

    def scalar_declaration(self, *args):
        """Write a scalar declaration."""
        raise NotImplementedError

    def tensor_declaration(self, *args):
        """Write a tensor declaration."""
        raise NotImplementedError

    def tensor_cleanup(self, *args):
        """Write a tensor cleanup."""
        raise NotImplementedError

    def algebraic_expression(self, output, expr):
        """Write an algebraic expression."""
        raise NotImplementedError

    def __call__(self, *args, **kwargs):
        return kernel(self, *args, **kwargs)

    def preamble(self):
        """Write the preamble."""
        self.module_docstring()
        self.blank()
        self.module_imports()
        self.blank()
        self.module_preamble("")
        self.blank()

    def postamble(self):
        """Write the postamble."""
        self.module_postamble("")
