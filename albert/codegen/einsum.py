"""Class for code generation using `einsum`-like syntax.
"""

from numbers import Number

from albert.algebra import Algebraic
from albert.codegen.base import CodeGen
from albert.tensor import Tensor


def _parse_indices(lhs, rhs):
    """
    Parse the indices in a `Mul` expression, and return the indices for
    the `einsum` call.
    """

    # Get the mapping of indices to index numbers
    index_numbers = {}
    indices = []
    for term in [*lhs, rhs]:
        term_indices = []
        for index in term:
            if index not in index_numbers:
                index_numbers[index] = len(index_numbers)
            term_indices.append(index_numbers[index])
        indices.append(tuple(term_indices))

    return indices


class EinsumCodeGen(CodeGen):
    """Class for code generation using `einsum`-like syntax."""

    def __init__(
        self,
        einsum_func="np.einsum",
        einsum_kwargs=None,
        transpose_func="np.transpose({arg}, {transpose})",
        name_generator=None,
        **kwargs,
    ):
        if einsum_kwargs is None:
            einsum_kwargs = {"optimize": True}
        super().__init__(
            einsum_func=einsum_func,
            einsum_kwargs=einsum_kwargs,
            transpose_func=transpose_func,
            name_generator=name_generator,
            **kwargs,
        )

    def module_imports(self, imports="import numpy as np"):
        """Write the module imports."""
        for line in imports.split("\n"):
            self.write(line)

    def module_preamble(self, preamble):
        """Write the module preamble."""
        pass

    def module_docstring(self):
        """Write the module docstring."""
        self.write('"""')
        self.write("Code generated by `albert`:")
        self.write("https://github.com/obackhouse/albert")
        self.blank()
        self.write("  * date: {date}".format(**self.get_metadata()))
        self.write("  * python version: {python_version}".format(**self.get_metadata()))
        self.write("  * albert version: {albert_version}".format(**self.get_metadata()))
        self.write("  * caller: {caller}".format(**self.get_metadata()))
        self.write("  * node: {node}".format(**self.get_metadata()))
        self.write("  * system: {system}".format(**self.get_metadata()))
        self.write("  * processor: {processor}".format(**self.get_metadata()))
        self.write("  * release: {release}".format(**self.get_metadata()))
        self.write('"""')

    def module_postamble(self, postamble):
        """Write the module postamble."""
        pass

    def function_declaration(self, name, args):
        """Write a function declaration."""
        kwargs = [f"{arg}=None" for arg in args]
        self.write(f"def {name}({', '.join(kwargs)}, **kwargs):")

    def function_preamble(self, preamble):
        """Write the function preamble."""
        for line in preamble.split("\n"):
            self.write(line)

    def function_docstring(self, docstring):
        """Write the function docstring."""
        self.write('"""')
        self.write(docstring)
        self.write('"""')

    def function_postamble(self, postamble):
        """Write the function postamble."""
        for line in postamble.split("\n"):
            self.write(line)

    def function_return(self, args, as_dict=False):
        """Write the function return."""
        if as_dict:
            args_str = ", ".join('f"{arg}": {arg}'.format(arg=arg) for arg in args)
            args_str = "{" + args_str + "}"
        else:
            args_str = ", ".join(args)
        self.write(f"return {args_str}")

    def scalar_declaration(self, *args):
        """Write a scalar declaration."""
        pass  # no need to declare scalars in Python

    def tensor_declaration(self, *args):
        """Write a tensor declaration."""
        pass  # no need to declare tensors in Python

    def tensor_cleanup(self, *args):
        """Write a tensor cleanup."""
        if args:
            args = tuple(self.get_name(arg) if isinstance(arg, Tensor) else arg for arg in args)
            self.write("del " + ", ".join(args))

    def algebraic_expression(self, output, expr, already_declared=False):
        """Write an algebraic expression."""

        assert isinstance(output, Tensor)
        assert isinstance(expr, (Tensor, Algebraic))

        for i, mul_args in enumerate(expr.nested_view()):
            # Separate the factors and tensors
            factors = [arg for arg in mul_args if isinstance(arg, Number)]
            tensors = [arg for arg in mul_args if isinstance(arg, Tensor)]

            # Get the indices
            lhs = [arg.indices for arg in tensors]
            rhs = output.indices
            indices = _parse_indices(lhs, rhs)

            # Get the arguments
            args = []
            for tensor, index in zip(tensors, indices):
                args.append(self.get_name(tensor))
                args.append(repr(index))
            args.append(repr(indices[-1]))

            # Get the operator and LHS
            operator = "=" if i == 0 and not already_declared else "+="
            output_name = self.get_name(output)

            # Get the factor
            factor = 1
            for f in factors:
                factor *= f
            if abs(factor - round(factor)) < 1e-12:
                factor = int(round(factor))
            factor = f" * {factor}" if factor != 1 else ""

            # Write the expression
            if len(tensors) > 1:
                if self.einsum_kwargs:
                    kwargs = ", " + ", ".join(f"{k}={v}" for k, v in self.einsum_kwargs.items())
                else:
                    kwargs = ""
                args = ", ".join(args)
                self.write(f"{output_name} {operator} {self.einsum_func}({args}{kwargs}){factor}")
            else:
                transpose = tuple(indices[0].index(i) for i in indices[1])
                if transpose != tuple(range(len(transpose))):
                    targ = self.transpose_func.format(arg=args[0], transpose=transpose)
                else:
                    targ = args[0]
                copy = ".copy()" if i == 0 and not already_declared else ""
                self.write(f"{output_name} {operator} {targ}{copy}{factor}")
